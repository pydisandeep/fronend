import copy
import logging
import re
from typing import Any, Dict, List

from schemas.vqc_state_new import VQCState, RuleApplicationResult, LabelRule
from helper_functions.detect_blank_element import is_blank_element

logger = logging.getLogger(__name__)


def apply_rule_node(state: VQCState) -> VQCState:
    generated_code = state.get("generated_code")
    rule: LabelRule = state.get("rule")  # type: ignore[assignment]
    elements: List[Dict[str, Any]] = state.get("elements") or []

    if not generated_code or rule is None:
        logger.info("apply_rule_node: no generated_code or rule present; skipping.")
        return state

    error_log: List[str] = state.get("error_log") or []
    results: List[RuleApplicationResult] = state.get("results") or []

    # ------------------------------------------------------------------
    # Build rule_config (for names + applies_to_elements)
    # ------------------------------------------------------------------
    if hasattr(rule, "model_dump"):
        rule_config: Dict[str, Any] = rule.model_dump()
    elif hasattr(rule, "dict"):
        rule_config = rule.dict()  # type: ignore[assignment]
    else:
        rule_config = dict(rule)   # type: ignore[arg-type]

    applies = rule_config.get("applies_to_elements")
    # Normalize None => no restriction
    if applies is None:
        applies = []
    if not isinstance(applies, list):
        applies = [applies]
    rule_config["applies_to_elements"] = applies

    def _element_type_allowed(elem_type: Any) -> bool:
        """
        If applies_to_elements is empty => no restriction.
        Else require elem_type to be in that list.
        """
        if not applies:
            return True
        return elem_type in applies

    # ------------------------------------------------------------------
    # Determine candidate function names (unchanged logic)
    # ------------------------------------------------------------------
    candidate_names: List[str] = []

    func_name_state = state.get("rule_function_name")
    if isinstance(func_name_state, str) and func_name_state.strip():
        candidate_names.append(func_name_state.strip())

    rule_name = rule_config.get("name") or getattr(rule, "name", None)
    if isinstance(rule_name, str) and rule_name.strip():
        rule_name_snake = re.sub(r"[^a-z0-9]+", "_", rule_name.lower()).strip("_")
        candidate_names.append(f"run_rule_{rule_name_snake}_check")

    user_input = rule_config.get("user_input") or getattr(rule, "user_input", None)
    if isinstance(user_input, str) and user_input.strip():
        ui_snake = re.sub(r"[^a-z0-9]+", "_", user_input.lower()).strip("_")
        candidate_names.append(f"run_rule_{ui_snake}_check")

    candidate_names.append("run_rule_unnamed_rule_check")

    seen = set()
    candidate_names = [c for c in candidate_names if not (c in seen or seen.add(c))]

    # ------------------------------------------------------------------
    # Exec the generated code and find the matching function
    # ------------------------------------------------------------------
    ns: Dict[str, Any] = {}
    try:
        exec(generated_code, ns)
    except Exception as e:
        msg = f"Failed to exec generated code for rule '{rule_name or 'unnamed'}': {e}"
        logger.error(msg)
        error_log.append(msg)
        return {**state, "error_log": error_log}

    rule_fn = None
    chosen_name = None

    for name in candidate_names:
        fn = ns.get(name)
        if callable(fn):
            rule_fn = fn
            chosen_name = name
            break

    if rule_fn is None:
        auto_candidates = [
            n for n, v in ns.items()
            if callable(v) and n.startswith("run_rule_") and n.endswith("_check")
        ]
        if len(auto_candidates) == 1:
            chosen_name = auto_candidates[0]
            rule_fn = ns[chosen_name]
            logger.warning(
                "apply_rule_node: auto-detected rule function '%s' "
                "since none of the expected names matched. Candidates tried: %s",
                chosen_name,
                candidate_names,
            )
        elif len(auto_candidates) > 1:
            chosen_name = auto_candidates[0]
            rule_fn = ns[chosen_name]
            logger.warning(
                "apply_rule_node: multiple run_rule_*_check functions found %s. "
                "Using '%s'. Candidates tried originally: %s",
                auto_candidates,
                chosen_name,
                candidate_names,
            )

    if rule_fn is None:
        msg = (
            "Generated code does not define an expected rule function. "
            f"Tried names: {candidate_names}"
        )
        logger.error(msg)
        error_log.append(msg)
        return {**state, "error_log": error_log}

    # Store resolved function name
    state["rule_function_name"] = chosen_name

    # ------------------------------------------------------------------
    # Helper: apply rule_fn to a single element (body paragraph, table,
    # or table cell paragraph).
    # ------------------------------------------------------------------
    def _apply_to_single_element(element: Dict[str, Any]) -> None:
        nonlocal results, error_log

        if not isinstance(element, dict):
            return

        element_id = element.get("element_id")
        element_type = element.get("type")

        # Filter by applies_to_elements if configured
        if not _element_type_allowed(element_type):
            return

        if is_blank_element(element):
            return

        try:
            result: RuleApplicationResult = rule_fn(element, rule_config)

            # Ensure we always have an element_id in the result
            if "element_id" not in result or result["element_id"] is None:
                result["element_id"] = element_id

            # Attach generated code for traceability
            result["code"] = generated_code
            results.append(result)

        except Exception as e:
            msg = (
                f"Error applying rule '{rule_name or 'unnamed'}' "
                f"to element {element_id}: {e}"
            )
            logger.error(msg)
            error_log.append(msg)

            failed_result: RuleApplicationResult = {
                "user_input": rule_config.get("user_input"),
                "instruction": rule_config.get("instruction"),
                "description": rule_config.get("description"),
                "rule": rule_config,
                "rule_id": rule_config.get("rule_id"),
                "element_id": element_id,
                "element_type": element_type,
                "passed": False,
                "comments": f"Rule execution failed with error: {e}",
                "original_element": copy.deepcopy(element),
                "updated_element": None,
                "status": "failed",
                "error_log": [msg],
                "execution_log": [],
                "code": generated_code,
            }
            results.append(failed_result)

    # ------------------------------------------------------------------
    # Apply rule to:
    #   - top-level elements (paragraphs, tables, etc.)
    #   - all cell paragraphs in every table via cells_paragraphs
    # ------------------------------------------------------------------
    for element in elements:
        el_type = element.get("type")

        # 1) Apply to the top-level element itself
        _apply_to_single_element(element)

        # 2) If this is a table, also apply to all nested cell paragraphs
        if el_type == "table":
            cells_paras = element.get("cells_paragraphs") or []
            for row in cells_paras:
                for cell_paras in row:
                    for p_meta in cell_paras:
                        if isinstance(p_meta, dict) and p_meta.get("type") == "paragraph":
                            _apply_to_single_element(p_meta)

    return {
        **state,
        "results": results,
        "error_log": error_log,
    }
